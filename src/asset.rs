//! Media type-agnostic asset handling
//!
//! This module provides a unified API for working with media files
//! without needing to know the specific media type.

use crate::{
    detect_container, error::Result, get_handler, structure::Structure, Container, Updates,
};
use std::fs::File;
use std::io::{Read, Seek, SeekFrom, Write};
use std::path::Path;

// Handler enum is generated by register_formats! macro in formats/mod.rs
use crate::Handler;

/// A media asset that automatically detects and handles its media type
///
/// # Example
///
/// ```no_run
/// use asset_io::{Asset, Updates};
///
/// # fn main() -> asset_io::Result<()> {
/// // Open any supported media file - media type is auto-detected
/// let mut asset = Asset::open("image.jpg")?;
///
/// // Read metadata
/// if let Some(xmp) = asset.xmp()? {
///     println!("XMP: {} bytes", xmp.len());
/// }
///
/// // Modify and write
/// let updates = Updates::new().set_xmp(b"<new>metadata</new>".to_vec());
/// asset.write_to("output.jpg", &updates)?;
/// # Ok(())
/// # }
/// ```
pub struct Asset<R: Read + Seek> {
    source: R,
    structure: Structure,
    handler: Handler,
}

// Handler enum and implementation are generated by register_formats! macro in lib.rs

impl Asset<File> {
    /// Open a media file from a path
    ///
    /// The media type is automatically detected from the file header.
    pub fn open<P: AsRef<Path>>(path: P) -> Result<Self> {
        let file = File::open(path)?;
        Self::from_file(file)
    }

    /// Create an Asset from an owned File
    pub fn from_file(mut file: File) -> Result<Self> {
        file.seek(SeekFrom::Start(0))?;
        let container = detect_container(&mut file)?;
        file.seek(SeekFrom::Start(0))?;

        let handler = get_handler(container)?;
        let structure = handler.parse(&mut file)?;

        Ok(Asset {
            source: file,
            structure,
            handler,
        })
    }

    /// Open a media file with memory mapping for zero-copy operations
    ///
    /// This method applies best practices for memory-mapped file access:
    /// - Opens the file read-only
    /// - Acquires an advisory shared lock (prevents cooperative writers)
    /// - Verifies file size stability during setup
    /// - Creates memory map for zero-copy access
    ///
    /// # Safety
    ///
    /// Memory mapping is inherently unsafe because:
    /// - **Advisory locks are cooperative**: They only prevent other processes
    ///   that also acquire locks. Non-cooperative processes can still modify the file.
    /// - **File modifications cause undefined behavior**: If the file is modified
    ///   by any process while mapped, reading from the map may cause crashes or
    ///   data corruption.
    ///
    /// Only use this method when:
    /// - You control all processes that access the file, OR
    /// - The file is read-only at the OS level, OR
    /// - You have external guarantees the file won't be modified
    ///
    /// # Performance
    ///
    /// Memory-mapped access provides:
    /// - Zero-copy reads (no buffer allocations)
    /// - OS-level page caching (shared across processes)
    /// - Significant speedup for large files (10-100x for hashing)
    ///
    /// # Example
    ///
    /// ```no_run
    /// use asset_io::Asset;
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// // Open with memory mapping (advisory lock acquired)
    /// let mut asset = unsafe { Asset::open_with_mmap("image.jpg")? };
    ///
    /// // Zero-copy access for hashing
    /// let ranges = asset.structure().hashable_ranges(&["jumbf"]);
    /// for range in ranges {
    ///     if let Some(slice) = asset.structure().get_mmap_slice(range) {
    ///         // Process slice directly from memory map (zero-copy!)
    ///     }
    /// }
    /// # Ok(())
    /// # }
    /// ```
    #[cfg(feature = "memory-mapped")]
    pub unsafe fn open_with_mmap<P: AsRef<Path>>(path: P) -> Result<Self> {
        #[allow(unused_imports)] // FileExt trait is used for lock_shared() method
        use fs2::FileExt;

        let path = path.as_ref();

        // Open read-only (best we can do for safety)
        let file = std::fs::OpenOptions::new()
            .read(true)
            .write(false)
            .open(path)?;

        // Get initial file metadata
        let metadata = file.metadata()?;
        let initial_size = metadata.len();

        // Acquire advisory shared lock (allows multiple concurrent readers)
        // This prevents cooperative writers but doesn't guarantee safety
        file.lock_shared()?;

        // Verify file size hasn't changed (basic race condition check)
        let current_size = file.metadata()?.len();
        if current_size != initial_size {
            file.unlock()?;
            return Err(crate::Error::InvalidFormat(
                "File size changed during open (file may be unstable)".into(),
            ));
        }

        // Create memory map (unsafe operation)
        let mmap = memmap2::Mmap::map(&file)?;

        // Create asset from file
        // Note: Advisory lock remains held as long as file handle exists
        let mut asset = Self::from_file(file)?;

        // Attach memory map for zero-copy access
        asset.structure.set_mmap(mmap);

        Ok(asset)
    }
}

impl<R: Read + Seek> Asset<R> {
    /// Create an Asset from a source (media type auto-detected)
    ///
    /// The media type is detected by reading the header. The source will be
    /// seeked to position 0 before detection.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use asset_io::Asset;
    /// use std::io::Cursor;
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// let jpeg_data = std::fs::read("image.jpg")?;
    /// let cursor = Cursor::new(jpeg_data);
    ///
    /// // Media type auto-detected from header
    /// let mut asset = Asset::from_source(cursor)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn from_source(mut source: R) -> Result<Self> {
        source.seek(SeekFrom::Start(0))?;
        let container = detect_container(&mut source)?;
        source.seek(SeekFrom::Start(0))?;

        let handler = get_handler(container)?;
        let structure = handler.parse(&mut source)?;

        Ok(Asset {
            source,
            structure,
            handler,
        })
    }

    /// Create an Asset from a source with a known format
    ///
    /// Use this when you already know the format or want to override
    /// auto-detection. This is slightly more efficient as it skips
    /// format detection.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use asset_io::{Asset, MediaType};
    /// use std::io::Cursor;
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// let data = vec![/* ... */];
    /// let cursor = Cursor::new(data);
    ///
    /// // Skip auto-detection when media type is known
    /// let mut asset = Asset::from_source_with_format(cursor, MediaType::Jpeg)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn from_source_with_format(mut source: R, format: crate::MediaType) -> Result<Self> {
        source.seek(SeekFrom::Start(0))?;
        let container = format.container();
        let handler = get_handler(container)?;
        let structure = handler.parse(&mut source)?;

        Ok(Asset {
            source,
            structure,
            handler,
        })
    }

    /// Get the detected format
    pub fn container(&self) -> Container {
        self.structure.container
    }

    /// Get the media type of this asset
    pub fn media_type(&self) -> crate::MediaType {
        self.structure.media_type
    }

    /// Get XMP metadata (loads lazily, assembles extended parts if present)
    pub fn xmp(&mut self) -> Result<Option<Vec<u8>>> {
        self.handler.extract_xmp(&self.structure, &mut self.source)
    }

    /// Get JUMBF data (loads and assembles lazily)
    pub fn jumbf(&mut self) -> Result<Option<Vec<u8>>> {
        self.handler
            .extract_jumbf(&self.structure, &mut self.source)
    }

    /// Extract an embedded thumbnail if available
    ///
    /// Many image formats include pre-rendered thumbnails for quick preview:
    /// - JPEG: EXIF thumbnail (typically 160x120)
    /// - PNG: EXIF thumbnail (if eXIf chunk present)
    ///
    /// This is the fastest way to get a thumbnail if available - no decoding needed!
    ///
    /// Returns `None` if:
    /// - No embedded thumbnail exists in the file
    /// - The format doesn't support embedded thumbnails
    /// - The `exif` feature is not enabled (required for thumbnail extraction)
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// // Try embedded thumbnail first (fastest!)
    /// if let Some(thumb) = asset.embedded_thumbnail()? {
    ///     println!("Found {}x{} thumbnail", thumb.width, thumb.height);
    ///     return Ok(thumb.data);
    /// }
    /// // Fall back to decoding main image
    /// ```
    pub fn embedded_thumbnail(&mut self) -> Result<Option<crate::EmbeddedThumbnail>> {
        #[cfg(feature = "exif")]
        {
            self.handler
                .extract_embedded_thumbnail(&self.structure, &mut self.source)
        }

        #[cfg(not(feature = "exif"))]
        {
            // Return None when exif feature is not enabled
            Ok(None)
        }
    }

    /// Get basic EXIF metadata (Make, Model, DateTime, etc.)
    ///
    /// Returns parsed EXIF information if the file contains EXIF data.
    /// This is a lightweight extraction of common EXIF fields.
    ///
    /// # Example
    /// ```no_run
    /// use asset_io::Asset;
    ///
    /// let mut asset = Asset::open("photo.jpg")?;
    /// if let Some(info) = asset.exif_info()? {
    ///     println!("Camera: {} {}", info.make.unwrap_or_default(), info.model.unwrap_or_default());
    ///     if let Some(dt) = info.date_time_original {
    ///         println!("Taken: {}", dt);
    ///     }
    /// }
    /// # Ok::<(), asset_io::Error>(())
    /// ```
    #[cfg(feature = "exif")]
    pub fn exif_info(&mut self) -> Result<Option<crate::tiff::ExifInfo>> {
        use crate::segment::SegmentKind;
        use std::io::SeekFrom;

        // Find EXIF segment
        let exif_segment = self
            .structure
            .segments
            .iter()
            .find(|s| s.is_type(SegmentKind::Exif));

        let segment = match exif_segment {
            Some(s) => s,
            None => return Ok(None),
        };

        // Read the EXIF data
        let location = segment.location();
        self.source.seek(SeekFrom::Start(location.offset))?;
        let mut data = vec![0u8; location.size as usize];
        self.source.read_exact(&mut data)?;

        // Parse based on container format
        let exif_data: &[u8] = match self.container() {
            crate::Container::Jpeg => {
                // JPEG: segment includes marker(2) + length(2) + "Exif\0\0"(6) + TIFF data
                // Skip: FF E1 + length(2) + Exif\0\0(6) = 10 bytes
                if data.len() > 10 && &data[4..10] == b"Exif\0\0" {
                    &data[10..]
                } else if data.len() > 4 {
                    // Maybe just marker + length, data starts at offset 4
                    &data[4..]
                } else {
                    return Ok(None);
                }
            }
            crate::Container::Png => {
                // PNG eXIf chunk: just raw TIFF data (no Exif\0\0 prefix)
                &data
            }
            _ => {
                // Try to detect format
                if data.starts_with(b"Exif\0\0") {
                    &data[6..]
                } else {
                    &data
                }
            }
        };

        crate::tiff::parse_exif_info(exif_data)
    }

    /// Get the file structure
    pub fn structure(&self) -> &Structure {
        &self.structure
    }

    /// Get mutable access to the file structure
    ///
    /// This is useful for advanced operations like attaching memory maps
    #[cfg(feature = "memory-mapped")]
    pub fn structure_mut(&mut self) -> &mut Structure {
        &mut self.structure
    }

    /// Get a mutable reference to the source
    ///
    /// This allows advanced operations like chunked reading for hashing
    pub fn source_mut(&mut self) -> &mut R {
        &mut self.source
    }

    /// Create a chunked reader for a byte range (convenience method)
    pub fn read_range_chunked(
        &mut self,
        range: crate::ByteRange,
        chunk_size: usize,
    ) -> Result<crate::ChunkedSegmentReader<std::io::Take<&mut R>>> {
        self.structure
            .read_range_chunked(&mut self.source, range, chunk_size)
    }

    /// Create a chunked reader for a segment (convenience method)
    pub fn read_segment_chunked(
        &mut self,
        segment_index: usize,
        chunk_size: usize,
    ) -> Result<crate::ChunkedSegmentReader<std::io::Take<&mut R>>> {
        self.structure
            .read_segment_chunked(&mut self.source, segment_index, chunk_size)
    }

    /// Process the asset's data with exclusions (read-side of write_with_processing)
    ///
    /// This is the read equivalent of `write_with_processing()`. It streams through
    /// the asset's data, calling the processor for each chunk while respecting
    /// the exclusion settings in `updates.processing`.
    ///
    /// Use this for:
    /// - Hashing an existing file
    /// - Validating data integrity
    /// - Calculating statistics
    /// - Any non-destructive processing
    ///
    /// # Example: Hash an existing file
    /// ```no_run
    /// use asset_io::{Asset, Updates, SegmentKind, ExclusionMode};
    /// use sha2::{Sha256, Digest};
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// let mut asset = Asset::open("signed.jpg")?;
    ///
    /// // Configure exclusions (same options as write_with_processing)
    /// let updates = Updates::new()
    ///     .exclude_from_processing(vec![SegmentKind::Jumbf], ExclusionMode::DataOnly);
    ///
    /// // Process the data
    /// let mut hasher = Sha256::new();
    /// asset.read_with_processing(&updates, &mut |chunk| hasher.update(chunk))?;
    /// let hash = hasher.finalize();
    /// # Ok(())
    /// # }
    /// ```
    pub fn read_with_processing<F>(
        &mut self,
        updates: &Updates,
        processor: &mut F,
    ) -> Result<()>
    where
        F: FnMut(&[u8]),
    {
        use crate::segment::DEFAULT_CHUNK_SIZE;
        
        let chunk_size = updates.processing.effective_chunk_size();
        let exclude_segments = &updates.processing.exclude_segments;
        let exclusion_mode = updates.processing.exclusion_mode;
        
        self.source.seek(SeekFrom::Start(0))?;
        
        // Build list of segment indices to exclude
        let excluded_indices: Vec<Option<usize>> = exclude_segments
            .iter()
            .filter_map(|kind| {
                self.structure.segments.iter().position(|s| s.is_type(*kind))
            })
            .map(Some)
            .collect();
        
        // Use existing structure method for streaming with exclusions
        let mut buffer = vec![0u8; chunk_size.min(DEFAULT_CHUNK_SIZE)];
        
        // Calculate ranges to process (everything except excluded segments)
        let mut ranges = Vec::new();
        let mut last_end = 0u64;
        
        for (idx, segment) in self.structure.segments.iter().enumerate() {
            let is_excluded = excluded_indices.contains(&Some(idx));
            
            if is_excluded {
                let loc = segment.location();
                // Determine exclusion range based on mode
                let (exclude_start, exclude_size) = if exclusion_mode == crate::ExclusionMode::DataOnly {
                    // DataOnly: exclude just the data portion (container-specific)
                    // For now, use the segment's data location
                    (loc.offset, loc.size)
                } else {
                    // EntireSegment: exclude the whole segment
                    (loc.offset, loc.size)
                };
                
                // Add range before this excluded segment
                if exclude_start > last_end {
                    ranges.push((last_end, exclude_start - last_end));
                }
                last_end = exclude_start + exclude_size;
            }
        }
        
        // Add final range after last exclusion
        if last_end < self.structure.total_size {
            ranges.push((last_end, self.structure.total_size - last_end));
        }
        
        // Process each range
        for (offset, size) in ranges {
            self.source.seek(SeekFrom::Start(offset))?;
            let mut remaining = size;
            
            while remaining > 0 {
                let to_read = remaining.min(buffer.len() as u64) as usize;
                self.source.read_exact(&mut buffer[..to_read])?;
                processor(&buffer[..to_read]);
                remaining -= to_read as u64;
            }
        }
        
        Ok(())
    }

    /// Hash the asset excluding specified segments (zero-copy with mmap)
    ///
    /// **Deprecated**: Use `read_with_processing()` instead for a unified API.
    ///
    /// # Example
    /// ```no_run
    /// # use asset_io::*;
    /// # use std::fs::File;
    /// # fn example() -> Result<()> {
    /// # let file = File::open("test.jpg")?;
    /// # let mut asset = Asset::from_source(file)?;
    /// use sha2::{Sha256, Digest};
    ///
    /// let mut hasher = Sha256::new();
    /// let c2pa_idx = asset.structure().c2pa_jumbf_index();
    /// asset.hash_excluding_segments(&[c2pa_idx], &mut hasher)?;
    /// let hash = hasher.finalize();
    /// # Ok(())
    /// # }
    /// ```
    #[deprecated(since = "0.2.0", note = "Use read_with_processing() instead")]
    #[allow(deprecated)]
    pub fn hash_excluding_segments<H: std::io::Write>(
        &mut self,
        excluded_indices: &[Option<usize>],
        hasher: &mut H,
    ) -> Result<()> {
        self.structure
            .hash_excluding_segments(&mut self.source, excluded_indices, hasher)
    }

    /// Write to a writer with updates
    pub fn write<W: Write>(&mut self, writer: &mut W, updates: &Updates) -> Result<()> {
        self.source.seek(SeekFrom::Start(0))?;
        self.handler
            .write(&self.structure, &mut self.source, writer, updates)
    }

    /// Write to a writer with updates and optional data processing callback
    ///
    /// This performs a streaming write where data can be processed (e.g., hashed)
    /// chunk by chunk as it's being written. This is much more efficient than
    /// writing first and then re-reading the file to hash it.
    ///
    /// The processor callback is called for each chunk of data being written,
    /// except for segments specified in `exclude_segments`. This allows you to:
    /// - Hash the asset while writing (C2PA use case)
    /// - Calculate checksums or statistics
    /// - Validate data during write
    ///
    /// Returns the destination structure, which can be used with
    /// `update_segment_with_structure` to perform in-place updates before
    /// finalizing the output.
    ///
    /// # Example: C2PA workflow
    /// ```no_run
    /// use asset_io::{Asset, Updates, SegmentKind, ExclusionMode};
    /// use sha2::{Sha256, Digest};
    /// use std::fs::File;
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// let mut asset = Asset::open("input.jpg")?;
    /// let mut output = File::create("output.jpg")?;
    ///
    /// // Prepare placeholder JUMBF with exclusion options
    /// let placeholder = vec![0u8; 20000];
    /// let updates = Updates::new()
    ///     .set_jumbf(placeholder)
    ///     .exclude_from_processing(vec![SegmentKind::Jumbf], ExclusionMode::DataOnly);
    ///
    /// // Write and hash in one pass
    /// let mut hasher = Sha256::new();
    /// let structure = asset.write_with_processing(
    ///     &mut output,
    ///     &updates,
    ///     &mut |chunk| hasher.update(chunk),
    /// )?;
    ///
    /// // Generate C2PA manifest using hash
    /// let hash = hasher.finalize();
    /// let manifest = vec![/* generate manifest with hash */];
    ///
    /// // Update JUMBF in-place before closing file
    /// asset_io::update_segment_with_structure(
    ///     &mut output,
    ///     &structure,
    ///     SegmentKind::Jumbf,
    ///     manifest,
    /// )?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn write_with_processing<W, F>(
        &mut self,
        writer: &mut W,
        updates: &Updates,
        processor: &mut F,
    ) -> Result<Structure>
    where
        W: Write + Seek,
        F: FnMut(&[u8]),
    {
        // Calculate destination structure
        let dest_structure = self
            .handler
            .calculate_updated_structure(&self.structure, updates)?;

        // Use the new write_with_processor method for true single-pass I/O
        self.source.seek(SeekFrom::Start(0))?;
        self.handler.write_with_processor(
            &self.structure,
            &mut self.source,
            writer,
            updates,
            processor,
        )?;

        Ok(dest_structure)
    }
}

// In-place update methods (require Read + Write + Seek)
impl<R: Read + Write + Seek> Asset<R> {
    /// Update a segment's data in-place without restructuring the file
    ///
    /// This efficiently updates metadata by overwriting existing bytes,
    /// avoiding the need to rewrite the entire file. Useful for:
    /// - C2PA manifest updates (placeholder â†’ signed)
    /// - XMP field updates (modify single property)
    /// - EXIF field updates (change camera settings metadata)
    ///
    /// # Requirements
    /// - New data must fit within existing segment capacity
    /// - File must be opened with read+write access
    /// - Data is padded with zeros if smaller than capacity
    ///
    /// # Returns
    /// - `Ok(bytes_written)` on success
    /// - `Err` if segment not found or data too large
    ///
    /// # Example
    /// ```no_run
    /// use asset_io::{Asset, SegmentKind};
    /// use std::fs::OpenOptions;
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// let file = OpenOptions::new()
    ///     .read(true)
    ///     .write(true)
    ///     .open("photo.jpg")?;
    /// let mut asset = Asset::from_source(file)?;
    ///
    /// // Update JUMBF in-place (e.g., after signing)
    /// let new_manifest = vec![/* signed manifest */];
    /// asset.update_segment_in_place(SegmentKind::Jumbf, new_manifest)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn update_segment_in_place(
        &mut self,
        kind: crate::segment::SegmentKind,
        new_data: Vec<u8>,
    ) -> Result<usize> {
        use crate::{error::Error, segment::SegmentKind};

        // Find the segment
        let segment_idx = match kind {
            SegmentKind::Jumbf => self.structure.c2pa_jumbf_index(),
            SegmentKind::Xmp => self.structure.xmp_index(),
            // EXIF not yet fully implemented in Structure
            _ => {
                return Err(Error::InvalidFormat(format!(
                    "In-place updates not supported for {:?}",
                    kind
                )))
            }
        }
        .ok_or_else(|| Error::InvalidFormat(format!("No existing {:?} segment found", kind)))?;

        let segment = &self.structure.segments[segment_idx];

        // Calculate total capacity across all ranges
        let total_capacity: u64 = segment.ranges.iter().map(|r| r.size).sum();

        // Validate size
        if new_data.len() as u64 > total_capacity {
            return Err(Error::InvalidFormat(format!(
                "New data ({} bytes) exceeds capacity ({} bytes)",
                new_data.len(),
                total_capacity
            )));
        }

        // Pad to exact capacity (preserves file structure)
        let mut padded = new_data;
        padded.resize(total_capacity as usize, 0);

        // Write across ranges
        let mut offset = 0;
        for range in &segment.ranges {
            self.source.seek(SeekFrom::Start(range.offset))?;
            let to_write = (padded.len() - offset).min(range.size as usize);
            self.source.write_all(&padded[offset..offset + to_write])?;
            offset += to_write;
            if offset >= padded.len() {
                break;
            }
        }

        self.source.flush()?;
        Ok(padded.len())
    }

    /// Get the available capacity for in-place updates of a segment type
    ///
    /// Returns `None` if no segment of that type exists.
    ///
    /// # Example
    /// ```no_run
    /// use asset_io::{Asset, SegmentKind};
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// let mut asset = Asset::open("photo.jpg")?;
    ///
    /// if let Some(capacity) = asset.segment_capacity(SegmentKind::Jumbf) {
    ///     println!("Can write up to {} bytes of JUMBF", capacity);
    /// }
    /// # Ok(())
    /// # }
    /// ```
    pub fn segment_capacity(&self, kind: crate::segment::SegmentKind) -> Option<u64> {
        use crate::segment::SegmentKind;

        let idx = match kind {
            SegmentKind::Jumbf => self.structure.c2pa_jumbf_index()?,
            SegmentKind::Xmp => self.structure.xmp_index()?,
            // EXIF not yet fully implemented in Structure
            _ => return None,
        };

        Some(
            self.structure.segments[idx]
                .ranges
                .iter()
                .map(|r| r.size)
                .sum(),
        )
    }

    /// Update C2PA JUMBF manifest in-place
    ///
    /// This is a convenience method for the common C2PA workflow where a
    /// placeholder manifest is written first, then replaced with the final
    /// signed manifest.
    ///
    /// # Example
    /// ```no_run
    /// use asset_io::{Asset, Updates};
    /// use std::fs::OpenOptions;
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// // Write placeholder
    /// let mut asset = Asset::open("input.jpg")?;
    /// let placeholder = vec![0u8; 20000]; // Reserve space
    /// asset.write_to("output.jpg", &Updates::new().set_jumbf(placeholder))?;
    ///
    /// // Sign and update in-place
    /// let final_manifest = vec![/* signed manifest */];
    /// let mut file = OpenOptions::new()
    ///     .read(true)
    ///     .write(true)
    ///     .open("output.jpg")?;
    /// let mut asset = Asset::from_source(file)?;
    /// asset.update_jumbf_in_place(final_manifest)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn update_jumbf_in_place(&mut self, new_jumbf: Vec<u8>) -> Result<usize> {
        self.update_segment_in_place(crate::segment::SegmentKind::Jumbf, new_jumbf)
    }

    /// Update XMP metadata in-place
    ///
    /// Useful for modifying XMP fields without rewriting the entire file.
    ///
    /// # Example
    /// ```no_run
    /// use asset_io::{Asset, xmp};
    /// use std::fs::OpenOptions;
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// let file = OpenOptions::new()
    ///     .read(true)
    ///     .write(true)
    ///     .open("photo.jpg")?;
    /// let mut asset = Asset::from_source(file)?;
    ///
    /// // Modify XMP
    /// let xmp = asset.xmp()?.expect("No XMP found");
    /// let xmp_str = String::from_utf8_lossy(&xmp);
    /// let updated = xmp::add_key(&xmp_str, "dc:title", "Updated Title")?;
    ///
    /// // Check if it fits
    /// if updated.len() as u64 <= asset.xmp_capacity().unwrap_or(0) {
    ///     asset.update_xmp_in_place(updated.into_bytes())?;  // Fast in-place update!
    /// }
    /// # Ok(())
    /// # }
    /// ```
    #[cfg(feature = "xmp")]
    pub fn update_xmp_in_place(&mut self, new_xmp: Vec<u8>) -> Result<usize> {
        self.update_segment_in_place(crate::segment::SegmentKind::Xmp, new_xmp)
    }

    /// Update EXIF metadata in-place
    ///
    /// # Example
    /// ```no_run
    /// use asset_io::Asset;
    /// use std::fs::OpenOptions;
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// let mut file = OpenOptions::new()
    ///     .read(true)
    ///     .write(true)
    ///     .open("photo.jpg")?;
    /// let mut asset = Asset::from_source(file)?;
    ///
    /// // Prepare new EXIF data (must fit in existing segment capacity)
    /// let new_exif = vec![/* EXIF TIFF data */];
    /// asset.update_exif_in_place(new_exif)?;
    /// # Ok(())
    /// # }
    /// ```
    #[cfg(feature = "exif")]
    pub fn update_exif_in_place(&mut self, new_exif: Vec<u8>) -> Result<usize> {
        self.update_segment_in_place(crate::segment::SegmentKind::Exif, new_exif)
    }

    /// Get capacity for JUMBF updates
    ///
    /// Returns `None` if the file has no JUMBF segment.
    pub fn jumbf_capacity(&self) -> Option<u64> {
        self.segment_capacity(crate::segment::SegmentKind::Jumbf)
    }

    /// Get capacity for XMP updates
    ///
    /// Returns `None` if the file has no XMP segment.
    #[cfg(feature = "xmp")]
    pub fn xmp_capacity(&self) -> Option<u64> {
        self.segment_capacity(crate::segment::SegmentKind::Xmp)
    }

    /// Get capacity for EXIF updates
    ///
    /// Returns `None` if the file has no EXIF segment.
    #[cfg(feature = "exif")]
    pub fn exif_capacity(&self) -> Option<u64> {
        self.segment_capacity(crate::segment::SegmentKind::Exif)
    }
}

impl<R: Read + Seek> Asset<R> {
    /// Create a virtual asset representing what would exist after applying updates
    ///
    /// No writing occurs. The virtual asset can be inspected, hashed, and
    /// eventually written when ready.
    ///
    /// # Example
    /// ```no_run
    /// use asset_io::{Asset, Updates};
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// let asset = Asset::open("input.jpg")?;
    /// let updates = Updates::new().set_jumbf(b"manifest".to_vec());
    ///
    /// // Create virtual asset (no I/O, instant)
    /// let virtual_asset = asset.with_updates(updates)?;
    ///
    /// // Inspect structure (for now, same as source - will be updated later)
    /// println!("Structure has {} segments", virtual_asset.structure().segments.len());
    ///
    /// // Write when ready
    /// let mut output = std::fs::File::create("output.jpg")?;
    /// virtual_asset.write_to(&mut output)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn with_updates(self, updates: Updates) -> Result<VirtualAsset<R>> {
        // Calculate the destination structure that would result from applying updates
        let dest_structure = self
            .handler
            .calculate_updated_structure(&self.structure, &updates)?;

        Ok(VirtualAsset {
            source_asset: self,
            dest_structure,
            updates,
        })
    }
}

impl Asset<File> {
    /// Write to a new file with updates
    pub fn write_to<P: AsRef<Path>>(&mut self, path: P, updates: &Updates) -> Result<()> {
        let mut output = File::create(path)?;
        self.source.seek(SeekFrom::Start(0))?;
        self.handler
            .write(&self.structure, &mut self.source, &mut output, updates)
    }
}

/// Builder for creating assets with custom options
pub struct AssetBuilder {
    // Future: Add options like memory mapping, buffer sizes, etc.
}

impl AssetBuilder {
    /// Create a new builder
    pub fn new() -> Self {
        Self {}
    }

    /// Open an asset with the configured options
    pub fn open<P: AsRef<Path>>(self, path: P) -> Result<Asset<File>> {
        Asset::open(path)
    }
}

impl Default for AssetBuilder {
    fn default() -> Self {
        Self::new()
    }
}

/// A virtual asset representing what would exist after applying updates
///
/// This is a "lazy" asset that hasn't been written yet. It can be inspected,
/// hashed, and eventually written. Safe by construction - the structure is
/// guaranteed to match because both are calculated from the same source and updates.
///
/// # Example
/// ```no_run
/// use asset_io::{Asset, Updates};
/// use sha2::{Sha256, Digest};
///
/// # fn main() -> asset_io::Result<()> {
/// let asset = Asset::open("input.jpg")?;
/// let updates = Updates::new().set_jumbf(b"manifest".to_vec());
///
/// // Create virtual asset (no writing yet!)
/// let virtual_asset = asset.with_updates(updates)?;
///
/// // Write when ready
/// let mut output = std::fs::File::create("output.jpg")?;
/// virtual_asset.write_to(&mut output)?;
/// # Ok(())
/// # }
/// ```
pub struct VirtualAsset<R: Read + Seek> {
    source_asset: Asset<R>,
    dest_structure: Structure,
    updates: Updates,
}

impl<R: Read + Seek> VirtualAsset<R> {
    /// Get the destination structure (what the file will look like after updates)
    pub fn structure(&self) -> &Structure {
        &self.dest_structure
    }

    /// Get immutable reference to the source asset
    pub fn source_asset(&self) -> &Asset<R> {
        &self.source_asset
    }

    /// Get mutable reference to the source asset
    pub fn source_asset_mut(&mut self) -> &mut Asset<R> {
        &mut self.source_asset
    }

    /// Get the updates that will be applied
    pub fn updates(&self) -> &Updates {
        &self.updates
    }

    /// Read XMP as it would appear in the output
    pub fn xmp(&mut self) -> Result<Option<Vec<u8>>> {
        use crate::MetadataUpdate;
        match &self.updates.xmp {
            MetadataUpdate::Set(data) => Ok(Some(data.clone())),
            MetadataUpdate::Remove => Ok(None),
            MetadataUpdate::Keep => self.source_asset.xmp(),
        }
    }

    /// Read JUMBF as it would appear in the output
    pub fn jumbf(&mut self) -> Result<Option<Vec<u8>>> {
        use crate::MetadataUpdate;
        match &self.updates.jumbf {
            MetadataUpdate::Set(data) => Ok(Some(data.clone())),
            MetadataUpdate::Remove => Ok(None),
            MetadataUpdate::Keep => self.source_asset.jumbf(),
        }
    }

    /// Write the virtual asset to a destination
    pub fn write_to<W: Write>(self, writer: &mut W) -> Result<()> {
        let mut source_asset = self.source_asset;
        source_asset.write(writer, &self.updates)
    }

    /// Write and convert to a real Asset (consumes writer)
    pub fn write_to_asset<W: Write + Read + Seek>(self, mut writer: W) -> Result<Asset<W>> {
        self.write_to(&mut writer)?;
        writer.seek(SeekFrom::Start(0))?;
        // Parse the written output to get real structure
        Asset::from_source(writer)
    }

    /// Apply additional updates to this virtual asset (chaining!)
    pub fn with_updates(self, updates: Updates) -> Result<VirtualAsset<R>> {
        // TODO: Merge updates intelligently
        // For now, just replace
        self.source_asset.with_updates(updates)
    }
}
