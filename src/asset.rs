//! Format-agnostic asset handling
//!
//! This module provides a unified API for working with media files
//! without needing to know the specific format.

use crate::{detect_format, error::Result, get_handler, structure::Structure, Format, Updates};
use std::fs::File;
use std::io::{Read, Seek, SeekFrom, Write};
use std::path::Path;

// Handler enum is generated by register_formats! macro in formats/mod.rs
use crate::Handler;

/// A media asset that automatically detects and handles its format
///
/// # Example
///
/// ```no_run
/// use asset_io::{Asset, Updates, XmpUpdate};
///
/// # fn main() -> asset_io::Result<()> {
/// // Open any supported media file - format is auto-detected
/// let mut asset = Asset::open("image.jpg")?;
///
/// // Read metadata
/// if let Some(xmp) = asset.xmp()? {
///     println!("XMP: {} bytes", xmp.len());
/// }
///
/// // Modify and write
/// let updates = Updates {
///     xmp: XmpUpdate::Set(b"<new>metadata</new>".to_vec()),
///     ..Default::default()
/// };
/// asset.write_to("output.jpg", &updates)?;
/// # Ok(())
/// # }
/// ```
pub struct Asset<R: Read + Seek> {
    reader: R,
    structure: Structure,
    handler: Handler,
}

// Handler enum and implementation are generated by register_formats! macro in lib.rs

impl Asset<File> {
    /// Open a media file from a path
    ///
    /// The format is automatically detected from the file header.
    pub fn open<P: AsRef<Path>>(path: P) -> Result<Self> {
        let file = File::open(path)?;
        Self::from_file(file)
    }

    /// Create an Asset from an owned File
    pub fn from_file(mut file: File) -> Result<Self> {
        file.seek(SeekFrom::Start(0))?;
        let format = detect_format(&mut file)?;
        file.seek(SeekFrom::Start(0))?;

        let handler = get_handler(format)?;
        let structure = handler.parse(&mut file)?;

        Ok(Asset {
            reader: file,
            structure,
            handler,
        })
    }

    /// Open a media file with memory mapping for zero-copy operations
    ///
    /// This method applies best practices for memory-mapped file access:
    /// - Opens the file read-only
    /// - Acquires an advisory shared lock (prevents cooperative writers)
    /// - Verifies file size stability during setup
    /// - Creates memory map for zero-copy access
    ///
    /// # Safety
    ///
    /// Memory mapping is inherently unsafe because:
    /// - **Advisory locks are cooperative**: They only prevent other processes
    ///   that also acquire locks. Non-cooperative processes can still modify the file.
    /// - **File modifications cause undefined behavior**: If the file is modified
    ///   by any process while mapped, reading from the map may cause crashes or
    ///   data corruption.
    ///
    /// Only use this method when:
    /// - You control all processes that access the file, OR
    /// - The file is read-only at the OS level, OR
    /// - You have external guarantees the file won't be modified
    ///
    /// # Performance
    ///
    /// Memory-mapped access provides:
    /// - Zero-copy reads (no buffer allocations)
    /// - OS-level page caching (shared across processes)
    /// - Significant speedup for large files (10-100x for hashing)
    ///
    /// # Example
    ///
    /// ```no_run
    /// use asset_io::Asset;
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// // Open with memory mapping (advisory lock acquired)
    /// let mut asset = unsafe { Asset::open_with_mmap("image.jpg")? };
    ///
    /// // Zero-copy access for hashing
    /// let ranges = asset.structure().hashable_ranges(&["jumbf"]);
    /// for range in ranges {
    ///     if let Some(slice) = asset.structure().get_mmap_slice(range) {
    ///         // Process slice directly from memory map (zero-copy!)
    ///     }
    /// }
    /// # Ok(())
    /// # }
    /// ```
    #[cfg(feature = "memory-mapped")]
    pub unsafe fn open_with_mmap<P: AsRef<Path>>(path: P) -> Result<Self> {
        #[allow(unused_imports)] // FileExt trait is used for lock_shared() method
        use fs2::FileExt;

        let path = path.as_ref();

        // Open read-only (best we can do for safety)
        let file = std::fs::OpenOptions::new()
            .read(true)
            .write(false)
            .open(path)?;

        // Get initial file metadata
        let metadata = file.metadata()?;
        let initial_size = metadata.len();

        // Acquire advisory shared lock (allows multiple concurrent readers)
        // This prevents cooperative writers but doesn't guarantee safety
        file.lock_shared()?;

        // Verify file size hasn't changed (basic race condition check)
        let current_size = file.metadata()?.len();
        if current_size != initial_size {
            file.unlock()?;
            return Err(crate::Error::InvalidFormat(
                "File size changed during open (file may be unstable)".into(),
            ));
        }

        // Create memory map (unsafe operation)
        let mmap = memmap2::Mmap::map(&file)?;

        // Create asset from file
        // Note: Advisory lock remains held as long as file handle exists
        let mut asset = Self::from_file(file)?;

        // Attach memory map for zero-copy access
        asset.structure.set_mmap(mmap);

        Ok(asset)
    }
}

impl<R: Read + Seek> Asset<R> {
    /// Create an Asset from a reader (format auto-detected)
    ///
    /// The format is detected by reading the header. The reader will be
    /// seeked to position 0 before detection.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use asset_io::Asset;
    /// use std::io::Cursor;
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// let jpeg_data = std::fs::read("image.jpg")?;
    /// let cursor = Cursor::new(jpeg_data);
    ///
    /// // Format auto-detected from header
    /// let mut asset = Asset::from_reader(cursor)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn from_reader(mut reader: R) -> Result<Self> {
        reader.seek(SeekFrom::Start(0))?;
        let format = detect_format(&mut reader)?;
        reader.seek(SeekFrom::Start(0))?;

        let handler = get_handler(format)?;
        let structure = handler.parse(&mut reader)?;

        Ok(Asset {
            reader,
            structure,
            handler,
        })
    }

    /// Create an Asset from a reader with a known format
    ///
    /// Use this when you already know the format or want to override
    /// auto-detection. This is slightly more efficient as it skips
    /// format detection.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use asset_io::{Asset, Format};
    /// use std::io::Cursor;
    ///
    /// # fn main() -> asset_io::Result<()> {
    /// let data = vec![/* ... */];
    /// let cursor = Cursor::new(data);
    ///
    /// // Skip auto-detection when format is known
    /// let mut asset = Asset::from_reader_with_format(cursor, Format::Jpeg)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn from_reader_with_format(mut reader: R, format: Format) -> Result<Self> {
        reader.seek(SeekFrom::Start(0))?;
        let handler = get_handler(format)?;
        let structure = handler.parse(&mut reader)?;

        Ok(Asset {
            reader,
            structure,
            handler,
        })
    }

    /// Get the detected format
    pub fn format(&self) -> Format {
        self.structure.format
    }

    /// Get XMP metadata (loads lazily, assembles extended parts if present)
    pub fn xmp(&mut self) -> Result<Option<Vec<u8>>> {
        self.handler.extract_xmp(&self.structure, &mut self.reader)
    }

    /// Get JUMBF data (loads and assembles lazily)
    pub fn jumbf(&mut self) -> Result<Option<Vec<u8>>> {
        self.handler
            .extract_jumbf(&self.structure, &mut self.reader)
    }

    /// Extract an embedded thumbnail if available
    ///
    /// Many image formats include pre-rendered thumbnails for quick preview:
    /// - JPEG: EXIF thumbnail (typically 160x120)
    /// - PNG: EXIF thumbnail (if eXIf chunk present)
    ///
    /// This is the fastest way to get a thumbnail if available - no decoding needed!
    ///
    /// Returns `None` if:
    /// - No embedded thumbnail exists in the file
    /// - The format doesn't support embedded thumbnails
    /// - The `exif` feature is not enabled (required for thumbnail extraction)
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// // Try embedded thumbnail first (fastest!)
    /// if let Some(thumb) = asset.embedded_thumbnail()? {
    ///     println!("Found {}x{} thumbnail", thumb.width, thumb.height);
    ///     return Ok(thumb.data);
    /// }
    /// // Fall back to decoding main image
    /// ```
    pub fn embedded_thumbnail(&mut self) -> Result<Option<crate::EmbeddedThumbnail>> {
        #[cfg(feature = "exif")]
        {
            self.handler
                .extract_embedded_thumbnail(&self.structure, &mut self.reader)
        }

        #[cfg(not(feature = "exif"))]
        {
            // Return None when exif feature is not enabled
            Ok(None)
        }
    }

    /// Get the file structure
    pub fn structure(&self) -> &Structure {
        &self.structure
    }

    /// Get mutable access to the file structure
    ///
    /// This is useful for advanced operations like attaching memory maps
    #[cfg(feature = "memory-mapped")]
    pub fn structure_mut(&mut self) -> &mut Structure {
        &mut self.structure
    }

    /// Get a mutable reference to the reader
    ///
    /// This allows advanced operations like chunked reading for hashing
    pub fn reader_mut(&mut self) -> &mut R {
        &mut self.reader
    }

    /// Create a chunked reader for a byte range (convenience method)
    pub fn read_range_chunked(
        &mut self,
        range: crate::ByteRange,
        chunk_size: usize,
    ) -> Result<crate::ChunkedSegmentReader<std::io::Take<&mut R>>> {
        self.structure
            .read_range_chunked(&mut self.reader, range, chunk_size)
    }

    /// Create a chunked reader for a segment (convenience method)
    pub fn read_segment_chunked(
        &mut self,
        segment_index: usize,
        chunk_size: usize,
    ) -> Result<crate::ChunkedSegmentReader<std::io::Take<&mut R>>> {
        self.structure
            .read_segment_chunked(&mut self.reader, segment_index, chunk_size)
    }

    /// Write to a writer with updates
    pub fn write<W: Write>(&mut self, writer: &mut W, updates: &Updates) -> Result<()> {
        self.reader.seek(SeekFrom::Start(0))?;
        self.handler
            .write(&self.structure, &mut self.reader, writer, updates)
    }
}

impl Asset<File> {
    /// Write to a new file with updates
    pub fn write_to<P: AsRef<Path>>(&mut self, path: P, updates: &Updates) -> Result<()> {
        let mut output = File::create(path)?;
        self.reader.seek(SeekFrom::Start(0))?;
        self.handler
            .write(&self.structure, &mut self.reader, &mut output, updates)
    }
}

/// Builder for creating assets with custom options
pub struct AssetBuilder {
    // Future: Add options like memory mapping, buffer sizes, etc.
}

impl AssetBuilder {
    /// Create a new builder
    pub fn new() -> Self {
        Self {}
    }

    /// Open an asset with the configured options
    pub fn open<P: AsRef<Path>>(self, path: P) -> Result<Asset<File>> {
        Asset::open(path)
    }
}

impl Default for AssetBuilder {
    fn default() -> Self {
        Self::new()
    }
}
